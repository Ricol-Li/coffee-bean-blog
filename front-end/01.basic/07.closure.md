# 闭包作用域和浏览器垃圾回收机制

## 浏览器垃圾回收机制「GC」

1. 标记清楚
2. 引用计数

[你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)

[JS 内存管理机制解析](https://www.imooc.com/read/70/article/1616)

## 作用域

**执行上下文存放在栈内存当中**

- 全局上下文：在浏览器打开页面的时候创建，在浏览器关闭页面的时候释放「F5 刷新：把上一次的释放，再形成一个新的」
- 私有上下文：默认情况下，代码执行完，都会出栈释放；但是如果上下文中的某些内容（一般指在内部创建的函数），被上下文以外的失误占用了，不仅被占用内容不能释放，连带着当前这个私有上下文也不能被释放！！

:::tip
闭包：函数执行，产生一个不被释放的上下文，这样不仅函数中的私有变量不受外加的干扰（保护），而且存储的信息也不会被释放掉（保存，可以供其下级上下文调取使用），我们把这种“保护+保存”的机制称之为闭包
:::

## 闭包练习题

### 练习题 1

```js
let x = 5
function fn(x) {
  return function (y) {
    console.log(y + ++x)
  }
}
let f = fn(6) //形参赋值 x = 6
// 形参赋值 y = 7
// y + ++6 = 14 此时x = 7
f(7)

// 函数重新执行，生成一个新的函数，新的私有上下文，x = 8 y = 9
// 9 + ++8 = 18
fn(8)(9)

// x = 7 y = 10
// y + ++7 = 18
f(10)

// 私有上下文的x，不影响全局上下文GO的x 输出5
console.log(x)
```

![closure_1](/images/closure_1.png)

### 练习题 2

```js
let a = 0,
  b = 0
function A(a) {
  A = function (b) {
    alert(a + b++)
  }
  alert(a++)
}
A(1) // 1 此时a变为2 函数A重新赋值
A(2) // a=2 b=2 a + b++ 输出 4 此时b=3
```

![closure_2](/images/closure_2.png)
